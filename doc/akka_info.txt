*akkainfo.txt*	       Akka Reference and Information	        Feb 21, 2011

Author:    Derek Wyatt <derek@{my first name}{my last name}.org>

Copyright: (c) 2011 by Derek Wyatt
           No license implied... use it for whatever tickles your particular
           fancy.

==============================================================================
0. Contents                                              *akka* *akka-contents*
------------------------------------------------------------------------------

  1. Actors..................................: |akka-actors|
    1.1 Defining by Derivation...............: |akka-actor-derive|
    1.2 Anonymous Creation...................: |akka-actor-anonymous|
    1.3 Actor vs. ActorRef...................: |akka-actor-actorref|


==============================================================================
1. Actors                                                   *akka-actors* {{{1
------------------------------------------------------------------------------

1.1 Actor Companion Object                            *akka-actor-object* {{{2
------------------------------------------------------------------------------

The {Actor} object provides some convenience methods for constructing some
"stuff":

actorOf(factory => Actor): ActorRef                      *akka-actor-actorOf1*
    Creates an ActorRef out of the Actor. Allows you to pass in a factory
    function that creates the Actor. Please note that this function can be
    invoked multiple times if for example the Actor is supervised and needs to
    be restarted.

    This function should NOT be used for remote actors.
!sc!
        import Actor._
        val actor = actorOf(new MyActor)
        actor.start
        actor ! message
        actor.stop
!/sc!
    You can create and start the actor in one statement like this:
!sc!
        val actor = actorOf(new MyActor).start!/sc!

actorOf(clazz: Class[_ <: akka.actor.Actor]): ActorRef   *akka-actor-actorOf2*
    Creates an ActorRef out of the Actor of the specified Class.
!sc!
        import Actor._
        val actor = actorOf(classOf[MyActor])
        actor.start
        actor ! message
        actor.stop
!/sc!
    You can create and start the actor in one statement like this:
!sc!
        val actor = actorOf(classOf[MyActor]).start!/sc!

                                                        *akka-actor-actorOf3*
actorOf[T <: Actor](implicit arg0: Manifest[T]): ActorRef
    Creates an ActorRef out of the Actor with type T.
!sc!
        import Actor._
        val actor = actorOf[MyActor]
        actor.start
        actor ! message
        actor.stop
!/sc!
    You can create and start the actor in one statement like this:
!sc!
        val actor = actorOf[MyActor].start!/sc!

{val} log : Logger                                          *akka-actor-log*
    This is merely a {val} which will will return the contextual SLF4J logger.

{val} registry : ActorRegistry                         *akka-actor-registry*
    This value contains the current {ActorRegistry} against which we can
    register and lookup different {Actor}s.  I can't find the code for this at
    the moment, so I'm not sure if it's actually {Actor}s or {ActorRef}s -
    probably the latter.

{lazy} {val} remote : RemoteSupport                      *akka-actor-remote*
    Provides access to the remoting system support for launching and accessing
    remote {Actor}s

                                                          *akka-actor-spawn*
spawn(body: => Unit)(implicit dispatcher: MessageDispatcher = ...) : Unit
    Use to spawn out a block of code in an event-driven actor. Will shut actor
    down when the block has been executed.

    NOTE: If used from within an Actor then has to be qualified with
    {Actor.spawn} since there is a method {spawn[ActorType]} in the Actor
    trait already. Example:
!sc!
        import Actor.{spawn}
        spawn {
            ... // do stuff
        }
!/sc!
1.2 Defining by Derivation                            *akka-actor-derive* {{{2
------------------------------------------------------------------------------
!sc!
    scala> import akka.actor._
    scala> import akka.actor.Actor._ 
    scala> class MyActor extends Actor {
         |   def receive = {
         |     case "hithere" =>
         |       println("Well, hello there")
         |   }
         | } 
    defined class MyActor

    scala> var a = actorOf[MyActor].start
    
    scala> a ! "hithere"
    Well, hello there
    
    scala> a.stop 
!/sc!

1.3 Anonymous Creation                             *akka-actor-anonymous* {{{2
------------------------------------------------------------------------------
!sc!
    scala> var a = actorOf(new Actor {
         |                   def receive = {
         |                     case "bite me" => println("NO!  Bite _ME_!")
         |                   }
         |                 })
    a: akka.actor.ActorRef = Actor[$anonfun$1$$anon$1:8c65a3d0-4379-11e0-9c39-005056c00008]

    scala> a ! "bite me"
    NO!  Bite _ME_!

    scala> a.stop
!/sc!

1.4 Actor vs. ActorRef                              *akka-actor-actorref* {{{2
------------------------------------------------------------------------------

One derives from {Actor} but the meat of things happens in the {ActorRef}, due
to the fact (I assume at this point) that the {ActorRef} provides the
mechanisms behind |akka-hotswap| and |akka-fault-tolerance|.  By divorcing the
implementation from the invocation, Akka can provide more execution framework
aspects that you no longer need to worry about.

The {actorOf} factory method available on the |akka-actor-object| provides the
ability to get an {ActorRef} from a derivation of {Actor}.

1.5 !, !!, and !!!                              *akka-actor-send-message* {{{2
------------------------------------------------------------------------------

Actors are all about passing messages around and the !, !! and !!! methods are
the {Actor}'s mechanisms for passing messages.

1.5.1 !                                                 *akka-actor-bang* {{{3
------------------------------------------------------------------------------

The simple ! message is the best way to send something - it's the one-way
fire-and-forget message that demands full asynchrony.  Obviously if you only
need a one-way message with no confirmation of delivery, you're fine just
sending it any never thinking about it again.  If, on the other hand, this
one-way message is actually part of a multi-message conversation, you need to
have some way of getting things back.

The most reliable way of doing this to demand an {ActorRef} as a parameter on
the message.
!sc!
    scala> case class GreetRequest(greeting: String, replyTo: ActorRef)
    defined class GreetRequest

    scala> case class GreetResponse(greeting: String)                                       
    defined class GreetResponse

    scala> class ServerActor extends Actor {                           
         |   def receive = {
         |     case GreetRequest(greeting, replyTo) =>
         |       replyTo ! GreetResponse("You said, '" + greeting +
         |                               "', and I say 'Thanks'")
         |   }
         | }

    scala> class ClientActor extends Actor {
         |   def receive = {
         |     case GreetResponse(greeting) =>
         |       println(greeting)
         |   }
         | }
    defined class ClientActor
    
    scala> var server = actorOf[ServerActor].start
    server: akka.actor.ActorRef = Actor[ServerActor:2d95a200-4384-11e0-9c39-005056c00008]
    
    scala> var client = actorOf[ClientActor].start
    client: akka.actor.ActorRef = Actor[ClientActor:34f5c160-4384-11e0-9c39-005056c00008]
    
    scala> server ! GreetRequest("Hithere, ServerActor", client)
    You said, 'Hithere, ServerActor', and I say 'Thanks'

    scala> client.stop

    scala> server.stop
!/sc!
You could also do this by using the {implicit} {sender}, contained inside the
{self.sender} field, but you always have to be wary of whether or not the
object that sent the message was actually an {Actor} or not.  The type of the
{self.sender} is {Option[AnyRef]}, which allows for the notion that the
{sender} is not an {Actor}.  So you have to keep checking it, and if your code
would always like to see one there, then it's easiest to simply force it in
the message and then it's there all the time.


1.5.2 !!                                           *akka-actor-bang-bang* {{{3
------------------------------------------------------------------------------

The !! method is a blocking call.  The implication is that the reciever is
going to use the {self.reply} method in order to send a result to the caller.
The caller is going to wait on a {Future} explicitly and get back an
{Option[Any]} object in return.  If the call did not time out then the
{Option} will be a {Some} that actually contains the result and {None}
otherwise.

There are a couple of things to note here:

- Blocking is bad...
- ... but so is not getting a result and not knowing that

The virtue of the !! method is that you'll know if something timed out.  If,
on the other hand you use the ! method and expect to be called back later, you
need some mechanism to ensure that you are actually called back.  Nobody's
going to tell you something timed out because the timing out is part of the
business logic, not the framework.

NOTE: I'm expecting Akka to help out here.  The fault tolerance in the system
based on {Supervisor}s should be able to buy us - not necessarily guaranteed
delivery - enough information in the system that lets us know when something
croaked while still maintaining fully asynchrony.
!sc!
    scala> case class SyncGreetRequest(greeting: String)
    defined class SyncGreetRequest
    
    scala> class SyncServerActor extends Actor {        
         |   def receive = {                            
         |     case SyncGreetRequest(greeting) =>       
         |       self.reply("You said, '" + greeting + "', and I say 'Thanks'")
         |   }
         | }
    defined class SyncServerActor
    
    scala> case class Go(server: ActorRef)
    defined class Go
    
    scala> class SyncClientActor extends Actor {                                    
         |   def receive = {                                                        
         |     case Go(server) =>                                                   
         |       println((server !! SyncGreetRequest("Hithere, SyncServerActor")).get)
         |   }
         | }
    defined class SyncClientActor
    
    scala> var client = actorOf[SyncClientActor].start
    client: akka.actor.ActorRef = Actor[SyncClientActor:28fb2af0-4387-11e0-9c39-005056c00008]
    
    scala> client ! Go(server) 
    You said, 'Hithere, SyncServerActor', and I say 'Thanks'
!/sc!
Note above that I simply call {get} on the {Option[Any]} I receive simply
because it's easy, but we have to remember that it is an {Option} object, so
it may not be valid to do that.


1.5.3 !!!                                     *akka-actor-bang-bang-bang* {{{3
------------------------------------------------------------------------------

The !!! method returns a {Future}.  This is a non-blocking call but requires
the management of the {Future} and possibly turns things into a degenerate
polling mechanism as a result.

There is a plus side here, though... the caller that receives the {Future}
need not be an {Actor}, as is the case in the !! call.  Using the exact same
{SyncServerActor} defined above, we have:
!sc!
    scala> val future = server !!! SyncGreetRequest("Hithere, SyncServerActor")
    future: akka.dispatch.Future[Nothing] =
      akka.dispatch.DefaultCompletableFuture@bf3fd22
    
    scala> future.result
    res16: Option[Nothing] =
      Some(You said, 'Hithere, SyncServerActor', and I say 'Thanks')
!/sc!

Modelines: {{{1
vim:tw=78:ts=4:ft=help:fdm=marker:fdl=0
